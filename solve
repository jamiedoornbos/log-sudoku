#!env python

import argparse, re, itertools, time, collections

NUMBERS = list(range(1, 10))


class SolveError(Exception):
    pass


class Location:
    def __init__(self, column, row):
        self.column = column
        self.row = row

    def __repr__(self):
        return f'({self.column + 1}, {self.row + 1})'


class Cell:
    def __init__(self, location: Location):
        assert location
        self.location = location
        self.groups = []
        self._allowed = set(NUMBERS)
        self._value = None

    @property
    def value(self):
        return self._value

    @value.setter
    def value(self, value):
        assert value
        self._value = value
        self._allowed = None
        for group in self.groups:
            group.cell_updated(self)

    @property
    def allowed(self) -> set[int]:
        return self._allowed

    def disallow(self, number):
        if self._value:
            if self.value == number:
                raise SolveError(f'Contradiction: disallowing {number} in {self}')
            return
        self._allowed.discard(number)
        if len(self._allowed) == 0:
            raise SolveError(f'Contradiction: nothing is allowed in {self}')

    def __repr__(self):
        base = f'cell at {self.location}'
        if self.value:
            return f'{base} (value {self.value})'
        allowed = ''.join(str(number) for number in self.allowed)
        return f'{base} (allowed {allowed})'


class Group:
    def __init__(self, name, cells):
        self.name = name
        self.cells = cells
        for cell in cells:
            cell.groups.append(self)

    def __iter__(self):
        return iter(self.cells)

    def __repr__(self):
        return self.name

    def cell_updated(self, cell: Cell):
        for other_cell in self.cells:
            if other_cell == cell:
                continue
            other_cell.disallow(cell.value)

    @property
    def open_cells(self):
        for cell in self.cells:
            if not cell.value:
                yield cell

    @property
    def filled_cells(self):
        for cell in self.cells:
            if cell.value:
                yield cell

    @property
    def type(self) -> str:
        return self.name[:3]

    def has_value(self, number):
        return any(cell.value == number for cell in self.filled_cells)


class Board:
    BOX_OFFSETS = [
        (column, row) for row in range(3) for column in range(3)
    ]

    BOX_CORNERS = [
        (f'''{'LCR'[row // 3]}{'TCB'[column // 3]}''', column, row)
        for row in (0, 3, 6) for column in (0, 3, 6)
    ]

    def __init__(self):
        n_range = range(len(NUMBERS))
        self.columns = [
            Group(f'Column {column + 1}', [Cell(Location(column, row)) for row in n_range]) for column in n_range]
        self.rows = [
            Group(f'Row {row + 1}', [self.get_cell(column, row) for column in n_range]) for row in n_range
        ]
        self.boxes = [
            Group(f'Box {name}', [self.get_cell(box_left + column, box_top + row) for column, row in self.BOX_OFFSETS])
            for name, box_left, box_top in self.BOX_CORNERS
        ]
        self.groups = self.rows + self.columns + self.boxes

    def get_cell(self, column, row):
        return self.columns[column].cells[row]

    def __iter__(self):
        for column in self.columns:
            yield from column

    @property
    def open_cells(self):
        for column in self.columns:
            yield from column.open_cells


class BoardPrinter:
    TOP, MIDDLE, MIDDLE_HEAVY, BOTTOM, CELL = (
        '═════'.join(['╔', '╤', '╤', '╦', '╤', '╤', '╦', '╤', '╤', '╗']),
        '─────'.join(['╟', '┼', '┼', '╫', '┼', '┼', '╫', '┼', '┼', '╢']),
        '═════'.join(['╠', '╪', '╪', '╬', '╪', '╪', '╬', '╪', '╪', '╣']),
        '═════'.join(['╚', '╧', '╧', '╩', '╧', '╧', '╩', '╧', '╧', '╝']),
        '║ {} │ {} │ {} ║ {} │ {} │ {} ║ {} │ {} │ {} ║'
    )

    @classmethod
    def format(cls, board: Board) -> str:
        lines = [cls.TOP]
        for row_number, row in enumerate(board.rows):
            if row_number:
                lines.append(cls.MIDDLE if row_number % 3 else cls.MIDDLE_HEAVY)
            formatted_cells = [cls.format_cell(cell) for cell in row]
            for line in range(len(formatted_cells[0])):
                lines.append(cls.CELL.format(*tuple(cell[line] for cell in formatted_cells)))
        lines.append(cls.BOTTOM)
        return '\n'.join(lines)

    @classmethod
    def format_cell(cls, cell: Cell) -> list[str]:
        if cell.value:
            # return ['┏━┓', f'┃{cell.value}┃', '┗━┛']
            # return ['   ', f' {cell.value} ', ' ▽ ']
            return ['╭─╮', f'│{cell.value}│', '╰─╯']
            # return ['╭ ╮', f' {cell.value} ', '╰ ╯']
            # return ['   ', f' {cell.value} ', ' ◦ ']
        grid = ''.join(' ' if number not in cell.allowed else str(number) for number in NUMBERS)
        return [grid[:3], grid[3:6], grid[6:]]


class BoardLoader:
    FORMAT = re.compile(r'^Format: (?P<format>\S+)$')
    COMMENT = re.compile(r'^\s*(#.*)?$')
    CELL_SEPARATOR = re.compile(r'\s+')
    START_FORMAT = 'start'
    SOLVER_FORMAT = 'solver'

    @classmethod
    def from_file(cls, path) -> 'Board':
        data_format = cls.START_FORMAT
        board_lines = []
        with open(path) as fp:
            for line in fp:
                match = cls.COMMENT.match(line)
                if match:
                    continue

                match = cls.FORMAT.match(line)
                if match:
                    data_format = match.group('format')
                    continue

                board_lines.append(line)

        size = len(NUMBERS)

        if len(board_lines) < size:
            raise Exception(f'Not enough rows {len(board_lines)}')

        if data_format not in (cls.START_FORMAT, cls.SOLVER_FORMAT):
            raise Exception(f'Invalid data format {data_format}')

        board = Board()
        board_lines = [line.rstrip() for line in board_lines[-size:]]

        if data_format == cls.START_FORMAT:
            for row_number, row in enumerate(board_lines):
                if len(row) != size:
                    raise Exception(f'Wrong number of columns in row {row_number}: {len(row)} ({repr(row)}')

                for column_number, value in enumerate(row):
                    location = (column_number, row_number)
                    if value not in ('.', ' '):
                        number = int(value)
                        if not (NUMBERS[0] <= number <= NUMBERS[-1]):
                            raise Exception(f'Cell at {location} is out of range: {value}')
                        board.get_cell(*location).value = number
            return board

        for row_number, row in enumerate(board_lines):
            row_cells = cls.CELL_SEPARATOR.split(row)
            if len(row_cells) != size:
                raise Exception(f'Wrong number of columns in row {row_number}: {len(row_cells)} ({repr(row)}')
            for column_number, value in enumerate(row_cells):
                location = (column_number, row_number)
                cell = board.get_cell(*location)
                if value.startswith('*'):
                    number = int(value[1:])
                    if not (NUMBERS[0] <= number <= NUMBERS[-1]):
                        raise Exception(f'Cell at {location} is out of range: {value}')
                    cell.value = number
                else:
                    for number in set(NUMBERS) - set(int(allowed) for allowed in value):
                        cell.disallow(number)

        return board

    @classmethod
    def append_to_file(cls, path, board, comment=None):
        with open(path, 'a') as fp:
            print(file=fp)
            if comment:
                print(f'# {comment}', file=fp)
            print(f'Format: {cls.SOLVER_FORMAT}', file=fp)
            for row in board.rows:
                formatted_cells = []
                for cell in row:
                    if cell.value:
                        formatted_cells.append(f'*{cell.value}')
                    else:
                        formatted_cells.append(''.join(str(number) for number in NUMBERS if number in cell.allowed))
                    formatted_cells[-1] += ' ' * (len(NUMBERS) - len(formatted_cells[-1]))
                print(' '.join(formatted_cells), file=fp)


class Solver:
    def __init__(self, board):
        self.board = board
        self.comment = None

    def is_solved(self) -> bool:
        return all(cell.value for cell in self.board)

    def one_move(self) -> bool:
        for cell in self.board:
            if not cell.value and len(cell.allowed) == 1:
                value = next(iter(cell.allowed))
                self.comment = f'In cell at {cell.location}, only {next(iter(cell.allowed))} is allowed'
                print(f'{self.comment}')
                cell.value = value
                return True

        for group in self.board.groups:
            for number in NUMBERS:
                if self.check_singular(group, number):
                    return True

        for size in (2, 3, 4, 5, 6):
            for group in self.board.groups:
                if self.check_subgroup(group, size):
                    return True

        for group in self.board.groups:
            for number in NUMBERS:
                if self.check_cross_group_elimination(group, number):
                    return True

        for number in NUMBERS:
            for groups, attr in (
                (self.board.rows, lambda _cell: _cell.column),
                (self.board.columns, lambda _cell: _cell.row)
            ):
                if self.check_cross_quads(groups, attr, number):
                    return True

        if self.check_fulcrum_pairs():
            return True

        return False

    def check_fulcrum_pairs(self):
        for fulcrum in self.board.open_cells:
            if len(fulcrum.allowed) != 2:
                continue
            for group1 in fulcrum.groups:
                for end1 in group1.open_cells:
                    if end1 == fulcrum or len(end1.allowed) != 2:
                        continue
                    allowed1 = end1.allowed
                    allowed2 = (allowed1 - fulcrum.allowed) | (fulcrum.allowed - allowed1)
                    if len(allowed2) != 2:
                        continue
                    for group2 in fulcrum.groups:
                        if group2 == group1:
                            continue
                        for end2 in group2.open_cells:
                            if end2.allowed != allowed2:
                                continue
                            overlap_number = next(iter(allowed1 & allowed2))
                            found = 0
                            for intersecting in self._intersecting_cells(end1, end2):
                                if overlap_number in intersecting.allowed:
                                    found += 1
                                    intersecting.disallow(overlap_number)
                            if found == 0:
                                continue
                            self.comment = f'{end1} and {end2} pivot against {fulcrum}'
                            print(f'{self.comment} - eliminated {overlap_number} from {found} other cells')
                            return True

        return False

    @staticmethod
    def _intersecting_cells(cell1, cell2):
        '''Find all cells that intersect with both but are not one of the cells.'''
        for group1 in cell1.groups:
            for cell in group1.open_cells:
                for group2 in cell2.groups:
                    if cell in group2.cells and cell not in (cell1, cell2):
                        yield cell

    def check_cross_quads(self, groups, coordinate_attr, number):
        allowed_cells = [
            [cell for cell in group.open_cells if number in cell.allowed]
            for group in groups
        ]
        allowed_pairs = [cells for cells in allowed_cells if len(cells) == 2]
        if len(allowed_pairs) < 2:
            return False

        def _key(cells):
            return frozenset(coordinate_attr(cell.location) for cell in cells)

        for key, cells in itertools.groupby(allowed_pairs, _key):
            cells = list(cells)
            if len(cells) == 2:
                print(f'QUADS: {number} in {cells}')

        return False

    def check_singular(self, group, number):
        if group.has_value(number):
            return False
        allowed_cells = [cell for cell in group.open_cells if number in cell.allowed]
        if len(allowed_cells) > 1:
            return False
        if len(allowed_cells) == 0:
            raise SolveError(f'Contradiction: {number} is not allowed in any cell in {group}')
        self.comment = f'{group} allows {number} only in {allowed_cells[0]}'
        print(f'{self.comment}')
        allowed_cells[0].value = number
        return True

    def check_subgroup(self, group, size):
        open_digits = set().union(*[cell.allowed for cell in group.open_cells])
        if len(open_digits) < size:
            return False
        for digits in map(set, itertools.combinations(open_digits, size)):
            subgroup = [cell for cell in group.open_cells if cell.allowed <= digits]
            if len(subgroup) != size:
                continue
            cell_count = 0
            for cell in group.open_cells:
                if cell in subgroup or not (to_disallow := cell.allowed & digits):
                    continue
                cell_count += 1
                for digit in to_disallow:
                    cell.disallow(digit)
            if not cell_count:
                continue
            digit_str = ''.join(str(digit) for digit in digits)
            self.comment = f'In {group}, cells allowing {digit_str} formed a subgroup'
            print(f'{self.comment} - disallowed digits in {cell_count} other cells in the group')
            return True

        return False

    def check_cross_group_elimination(self, group, number):
        if group.has_value(number):
            return False

        type_groups = collections.defaultdict(list)
        for cell in group:
            if cell.value or number not in cell.allowed:
                continue
            for other_group in cell.groups:
                if other_group == group or other_group in type_groups[other_group.type]:
                    continue
                type_groups[other_group.type].append(other_group)

        singles = [group_list[0] for group_list in type_groups.values() if len(group_list) == 1]
        if not singles:
            return False

        cross_group, marked = singles[0], 0
        for cell in cross_group:
            if group in cell.groups or cell.value or number not in cell.allowed:
                continue
            cell.disallow(number)
            marked += 1

        if marked:
            self.comment = f'In {group}, cells allowing {number} were exclusively in {cross_group}'
            print(f'{self.comment} - disallowed {number} in {marked} cells in {cross_group}')
            return True

        return False


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('file', metavar='PATH', help='file of puzzle')
    parser.add_argument('--solve', action='store_true', help='Run until done')
    parser.add_argument('--delay', metavar='SECONDS', help='Sleep between solving turns', type=float, default=0)
    args = parser.parse_args()

    board = BoardLoader.from_file(args.file)
    solver = Solver(board)
    while True:
        if solver.is_solved():
            print('Solved!')
            break
        if not solver.one_move():
            print('No moves found!')
            break
        BoardLoader.append_to_file(args.file, board, solver.comment)
        print(BoardPrinter.format(board))
        if not args.solve:
            break
        time.sleep(args.delay)


if __name__ == '__main__':
    main()
